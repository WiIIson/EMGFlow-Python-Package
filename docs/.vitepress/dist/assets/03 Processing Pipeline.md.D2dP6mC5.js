import{_ as o,c as a,o as t,ae as i}from"./chunks/framework.Dh1jimFm.js";const p=JSON.parse('{"title":"Processing Pipeline","description":"","frontmatter":{},"headers":[],"relativePath":"03 Processing Pipeline.md","filePath":"03 Processing Pipeline.md"}'),s={name:"03 Processing Pipeline.md"};function r(n,e,l,d,c,h){return t(),a("div",null,e[0]||(e[0]=[i('<h1 id="processing-pipeline" tabindex="-1">Processing Pipeline <a class="header-anchor" href="#processing-pipeline" aria-label="Permalink to &quot;Processing Pipeline&quot;">​</a></h1><p>EMGFlow is broken into 5 parts - accessing files, preprocessing signals, extracting features, detecting outliers, and creating visualizations. Descriptions of functions for each part are grouped together on the same documentation page</p><hr><h2 id="file-format" tabindex="-1">File Format <a class="header-anchor" href="#file-format" aria-label="Permalink to &quot;File Format&quot;">​</a></h2><p>The EMGFlow Python package works with CSV files, but is planned to expand to other file formats in the future. To prepare your data to be compatible with EMGFlow, it needs to be a CSV file with ideally a &quot;Time&quot; column, and additional columns for the signals you have recorded. &quot;Time&quot; should contain the time from 0 the signal has been recorded for, and the additional columns will have the recording of the signals at that time. Additionally, the file should have a constant sampling rate (time difference between each sequential row).</p><h2 id="fileaccess-module" tabindex="-1"><code>FileAccess</code> Module <a class="header-anchor" href="#fileaccess-module" aria-label="Permalink to &quot;`FileAccess` Module&quot;">​</a></h2><p>These functions provide helper methods for accessing files, and are mostly used internally by the package.</p><p>One notable function, <code>MapFiles</code>, takes a path to a folder, and generates a dictionary of paths to files contained within. This makes it easier to create a loop over subfiles, reading them in and performing analysis.</p><p><code>MapFiles</code> forms the basis for the two modes of analysis offered by EMGFlow - automated, or manual.</p><p>The &quot;automated&quot; mode makes the processing pipeline much simpler. In these functions, a file location is provided, default parameters are set, and a file output location is set. The functions then apply the filters to each file found in the folder, and output the filtered files to the output folder. Notable functions include:</p><ul><li><code>NotchFilterSignals</code></li><li><code>BandpassFilterSignals</code></li><li><code>SmoothFilterSignals</code></li></ul><p>The &quot;manual&quot; mode allows for additional customization of processing. In these functions, a dataframe is provided, filter parameters are set, and the dataframe is returned. These functions are useful if the processing pipeline requires further additional processing before being outputted, of if the project is not large-scale enough to warrent batch processing. Notable functions include:</p><ul><li><code>ApplyNotchFilters</code></li><li><code>ApplyBandpassFilter</code></li><li><code>ApplyRMSSmooth</code></li></ul><p>For more information about file accessing functions, see <a href="./04 FileAccess API.html">FileAccess API</a>.</p><hr><h2 id="preprocesssignals-module" tabindex="-1"><code>PreprocessSignals</code> Module <a class="header-anchor" href="#preprocesssignals-module" aria-label="Permalink to &quot;`PreprocessSignals` Module&quot;">​</a></h2><p>This module provides preprocessing functions for cleaning sEMG signals prior to their use in feature extraction. Signal processing is broken into 3 parts: notch filtering, bandpass filtering and smoothing. Each part has additional functions that support more specific needs, explained in more detail in the module descriptions.</p><h3 id="notchfiltersignals" tabindex="-1"><code>NotchFilterSignals()</code> <a class="header-anchor" href="#notchfiltersignals" aria-label="Permalink to &quot;`NotchFilterSignals()`&quot;">​</a></h3><p>Notch filtering involves filtering specific frequencies. This is typically due to some sort of interference, such as the power source of the device taking the reading.</p><p><code>NotchFilterSignals()</code> provides flexibility for use in different regions of the world. Some filtering packages only provide notch filtering for 60Hz, the frequency where power can interfere with signal readings. However, other regions use 50Hz frequencies.</p><p>For more information about further customizations and detail about <code>NotchFilterSignals()</code>, see <a href="./05 PreprocessSignals API.html">PreprocessSignals API</a>.</p><h3 id="bandpassfiltersignals" tabindex="-1"><code>BandpassFilterSignals()</code> <a class="header-anchor" href="#bandpassfiltersignals" aria-label="Permalink to &quot;`BandpassFilterSignals()`&quot;">​</a></h3><p>Bandpass filtering involves specifying a range of frequencies to keep, and removing all other frequencies outside this range. This is useful to remove interference outside the most meaningful range of readings.</p><p><code>BandpassFilterSignals()</code> uses bandpass thresholds of 20Hz and 450Hz, as this is default for EMG signals (De Luca et al., 2010). However, there is some disagreement within literature for different muscels, so <code>BandpassFilterSignals()</code> provides the option to change the thresholds.</p><p>For more information about further customizations and detail about <code>BandpassFilterSignals()</code>, see <a href="./05 PreprocessSignals API.html">PreprocessSignals API</a>.</p><h3 id="smoothfiltersignals" tabindex="-1"><code>SmoothFilterSignals()</code> <a class="header-anchor" href="#smoothfiltersignals" aria-label="Permalink to &quot;`SmoothFilterSignals()`&quot;">​</a></h3><p>Smoothing involves limiting the impacts of noise and outliers in the signal. By default, this function uses the RMS smoothing method, as it is the best choice for smoothing EMG signals (RENSHAW et al., 2010).</p><p><code>SmoothFilterSignals()</code> by default uses the RMS smoothing method, as it is the best choice for filtering EMG signals (RENSHAW et al., 2010). Regardless, EMGFlow provides different methods for smoothing signals which can be used instead.</p><p>For more information about further customizations and detail about <code>SmoothFilterSignals()</code>, see <a href="./05 PreprocessSignals API.html">PreprocessSignals API</a>.</p><hr><h2 id="extractfeatures-module" tabindex="-1"><code>ExtractFeatures</code> Module <a class="header-anchor" href="#extractfeatures-module" aria-label="Permalink to &quot;`ExtractFeatures` Module&quot;">​</a></h2><p>This module takes preprocessed data, and extracts features from the sEMG signal that capture information in both time and frequency domains. The main function to do this is <code>ExtractFeatures</code>. Within this call, individual features are calculated by their own functions, allowing them to be incorporated into your own workflow.</p><h3 id="extractfeatures" tabindex="-1"><code>ExtractFeatures()</code> <a class="header-anchor" href="#extractfeatures" aria-label="Permalink to &quot;`ExtractFeatures()`&quot;">​</a></h3><p>Analysis involves extracting the features from each signal into a feature file. This is the end of the pipeline, producing the final result.</p><p>For a more detailed explanation about the features extracted by <code>AnalyzeSignals()</code>, see <a href="./06 ExtractFeatures API.html">ExtractFeatures API</a>.</p><hr><h2 id="outlierfinder-module" tabindex="-1"><code>OutlierFinder</code> Module <a class="header-anchor" href="#outlierfinder-module" aria-label="Permalink to &quot;`OutlierFinder` Module&quot;">​</a></h2><p>This module provides methods to help detect signal files that contain outliers. This helps for workflows involving batch processing of files, where it might be harder to determine if there are any patterns, or specific files that need additional filters applied.</p><p>Outlier detection is handled by the function <code>DetectOutliers()</code>. This function outputs a dictionary of file names and locations for each signal marked as an outlier.</p><p>For more information about further customizations and specifications that can be made to <code>DetectOutliers()</code>, see <a href="./07 OutlierFinder API.html">OutlierFinder API</a>.</p><hr><h2 id="plotsignals-module" tabindex="-1"><code>PlotSignals</code> Module <a class="header-anchor" href="#plotsignals-module" aria-label="Permalink to &quot;`PlotSignals` Module&quot;">​</a></h2><p>The plotting module <code>PlotSignals</code> provides functions to help visualize individual, or large batches of signal data. This helps visually see what is happening in a signal to identify outliers, and determine the kinds of filters that need to be applied.</p><p>For more information about further customizations and specifications that can be made to <code>PlotSpectrum()</code>, see <a href="./08 PlotSignals API.html">PlotSignals API</a>.</p><h3 id="plotcomparesignals" tabindex="-1"><code>PlotCompareSignals()</code> <a class="header-anchor" href="#plotcomparesignals" aria-label="Permalink to &quot;`PlotCompareSignals()`&quot;">​</a></h3><p><code>PlotCompareSignals()</code> compares plots of signals for two different stages of processing.</p><p>For more information about further customizations and specifications that can be made to <code>PlotCompareSignals()</code>, see <a href="./08 PlotSignals API.html">PlotSignals API</a>.</p><hr><h2 id="sources" tabindex="-1">Sources <a class="header-anchor" href="#sources" aria-label="Permalink to &quot;Sources&quot;">​</a></h2><p>De Luca, C., Gilmore, L., Kuznetsov, M., &amp; Roy, S. (2010). Filtering the surface EMG signal: Movement artifact and baseline noise contamination. <em>Journal of Biomechanics</em>, <em>43</em>, 1.</p><p>RENSHAW, D., BICE, M. R., CASSIDY, C., ELDRIDGE, J. A., &amp; POWELL, D. W. (2010). A Comparison of Three Computer-based Methods Used to Determine EMG Signal Amplitude. <em>International Journal of Exercise Science</em>, <em>3</em>(1), 43–48.</p>',51)]))}const f=o(s,[["render",r]]);export{p as __pageData,f as default};
