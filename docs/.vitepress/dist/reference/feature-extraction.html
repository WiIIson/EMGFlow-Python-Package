<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ExtractFeatures Module Documentation | EMG Workflow</title>
    <meta name="description" content="The open workflow for EMG signal processing and feature extraction">
    <meta name="generator" content="VitePress v1.6.3">
    <link rel="preload stylesheet" href="/EMGFlow-Python-Package/assets/style.zXgIiM5k.css" as="style">
    <link rel="preload stylesheet" href="/EMGFlow-Python-Package/vp-icons.css" as="style">
    
    <script type="module" src="/EMGFlow-Python-Package/assets/app.CTYQFeld.js"></script>
    <link rel="preload" href="/EMGFlow-Python-Package/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/EMGFlow-Python-Package/assets/chunks/theme.BLkqR34a.js">
    <link rel="modulepreload" href="/EMGFlow-Python-Package/assets/chunks/framework.CgPgIgqO.js">
    <link rel="modulepreload" href="/EMGFlow-Python-Package/assets/reference_feature-extraction.md.DRCeW4iC.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-d8d3e66f><!--[--><!--]--><!--[--><span tabindex="-1" data-v-aff08a50></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-aff08a50>Skip to content</a><!--]--><!----><header class="VPNav" data-v-d8d3e66f data-v-64278d09><div class="VPNavBar" data-v-64278d09 data-v-2f9a91a8><div class="wrapper" data-v-2f9a91a8><div class="container" data-v-2f9a91a8><div class="title" data-v-2f9a91a8><div class="VPNavBarTitle has-sidebar" data-v-2f9a91a8 data-v-db1abf29><a class="title" href="/EMGFlow-Python-Package/" data-v-db1abf29><!--[--><!--]--><!--[--><img class="VPImage logo" src="./EMGFlow.png" alt data-v-4f649717><!--]--><span data-v-db1abf29>EMGFlow</span><!--[--><!--]--></a></div></div><div class="content" data-v-2f9a91a8><div class="content-body" data-v-2f9a91a8><!--[--><!--]--><div class="VPNavBarSearch search" data-v-2f9a91a8><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-2f9a91a8 data-v-94e0de4d><span id="main-nav-aria-label" class="visually-hidden" data-v-94e0de4d> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/EMGFlow-Python-Package/guide/what-is-emgflow.html" tabindex="0" data-v-94e0de4d data-v-b04b12fe><!--[--><span data-v-b04b12fe>Guide</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/EMGFlow-Python-Package/reference/api-overview.html" tabindex="0" data-v-94e0de4d data-v-b04b12fe><!--[--><span data-v-b04b12fe>Reference</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/EMGFlow-Python-Package/about/authors.html" tabindex="0" data-v-94e0de4d data-v-b04b12fe><!--[--><span data-v-b04b12fe>About Us</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-2f9a91a8 data-v-e6826308><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-e6826308 data-v-77e720fe data-v-b5a0f3c5><span class="check" data-v-b5a0f3c5><span class="icon" data-v-b5a0f3c5><!--[--><span class="vpi-sun sun" data-v-77e720fe></span><span class="vpi-moon moon" data-v-77e720fe></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-2f9a91a8 data-v-cb473b7f data-v-e0cde419><!--[--><a class="VPSocialLink no-icon" href="https://github.com/WiIIson/EMGFlow-Python-Package" aria-label="github" target="_blank" rel="noopener" data-v-e0cde419 data-v-6b91c750><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-2f9a91a8 data-v-c4883afd data-v-3980e32a><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-3980e32a><span class="vpi-more-horizontal icon" data-v-3980e32a></span></button><div class="menu" data-v-3980e32a><div class="VPMenu" data-v-3980e32a data-v-f8f1a359><!----><!--[--><!--[--><!----><div class="group" data-v-c4883afd><div class="item appearance" data-v-c4883afd><p class="label" data-v-c4883afd>Appearance</p><div class="appearance-action" data-v-c4883afd><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-c4883afd data-v-77e720fe data-v-b5a0f3c5><span class="check" data-v-b5a0f3c5><span class="icon" data-v-b5a0f3c5><!--[--><span class="vpi-sun sun" data-v-77e720fe></span><span class="vpi-moon moon" data-v-77e720fe></span><!--]--></span></span></button></div></div></div><div class="group" data-v-c4883afd><div class="item social-links" data-v-c4883afd><div class="VPSocialLinks social-links-list" data-v-c4883afd data-v-e0cde419><!--[--><a class="VPSocialLink no-icon" href="https://github.com/WiIIson/EMGFlow-Python-Package" aria-label="github" target="_blank" rel="noopener" data-v-e0cde419 data-v-6b91c750><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-2f9a91a8 data-v-6c970607><span class="container" data-v-6c970607><span class="top" data-v-6c970607></span><span class="middle" data-v-6c970607></span><span class="bottom" data-v-6c970607></span></span></button></div></div></div></div><div class="divider" data-v-2f9a91a8><div class="divider-line" data-v-2f9a91a8></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-d8d3e66f data-v-f3371c70><div class="container" data-v-f3371c70><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-f3371c70><span class="vpi-align-left menu-icon" data-v-f3371c70></span><span class="menu-text" data-v-f3371c70>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-f3371c70 data-v-1526310c><button data-v-1526310c>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-d8d3e66f data-v-77192a04><div class="curtain" data-v-77192a04></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-77192a04><span class="visually-hidden" id="sidebar-aria-label" data-v-77192a04> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-8e2b8225><section class="VPSidebarItem level-0" data-v-8e2b8225 data-v-8b85607e><div class="item" role="button" tabindex="0" data-v-8b85607e><div class="indicator" data-v-8b85607e></div><h2 class="text" data-v-8b85607e>Introduction</h2><!----></div><div class="items" data-v-8b85607e><!--[--><div class="VPSidebarItem level-1 is-link" data-v-8b85607e data-v-8b85607e><div class="item" data-v-8b85607e><div class="indicator" data-v-8b85607e></div><a class="VPLink link link" href="/EMGFlow-Python-Package/guide/what-is-emgflow.html" data-v-8b85607e><!--[--><p class="text" data-v-8b85607e>What is EMGFlow?</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8b85607e data-v-8b85607e><div class="item" data-v-8b85607e><div class="indicator" data-v-8b85607e></div><a class="VPLink link link" href="/EMGFlow-Python-Package/guide/getting-started.html" data-v-8b85607e><!--[--><p class="text" data-v-8b85607e>Getting started</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8b85607e data-v-8b85607e><div class="item" data-v-8b85607e><div class="indicator" data-v-8b85607e></div><a class="VPLink link link" href="/EMGFlow-Python-Package/guide/examples.html" data-v-8b85607e><!--[--><p class="text" data-v-8b85607e>Examples</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8b85607e data-v-8b85607e><div class="item" data-v-8b85607e><div class="indicator" data-v-8b85607e></div><a class="VPLink link link" href="/EMGFlow-Python-Package/guide/about-emg.html" data-v-8b85607e><!--[--><p class="text" data-v-8b85607e>About electromyography</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-8e2b8225><section class="VPSidebarItem level-0 has-active" data-v-8e2b8225 data-v-8b85607e><div class="item" role="button" tabindex="0" data-v-8b85607e><div class="indicator" data-v-8b85607e></div><h2 class="text" data-v-8b85607e>Reference</h2><!----></div><div class="items" data-v-8b85607e><!--[--><div class="VPSidebarItem level-1 is-link" data-v-8b85607e data-v-8b85607e><div class="item" data-v-8b85607e><div class="indicator" data-v-8b85607e></div><a class="VPLink link link" href="/EMGFlow-Python-Package/reference/api-overview.html" data-v-8b85607e><!--[--><p class="text" data-v-8b85607e>Overview</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8b85607e data-v-8b85607e><div class="item" data-v-8b85607e><div class="indicator" data-v-8b85607e></div><a class="VPLink link link" href="/EMGFlow-Python-Package/reference/preprocess-signals.html" data-v-8b85607e><!--[--><p class="text" data-v-8b85607e>Pre-processing</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8b85607e data-v-8b85607e><div class="item" data-v-8b85607e><div class="indicator" data-v-8b85607e></div><a class="VPLink link link" href="/EMGFlow-Python-Package/reference/feature-extraction.html" data-v-8b85607e><!--[--><p class="text" data-v-8b85607e>Feature extraction</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8b85607e data-v-8b85607e><div class="item" data-v-8b85607e><div class="indicator" data-v-8b85607e></div><a class="VPLink link link" href="/EMGFlow-Python-Package/reference/plot-signals.html" data-v-8b85607e><!--[--><p class="text" data-v-8b85607e>Plotting signals</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8b85607e data-v-8b85607e><div class="item" data-v-8b85607e><div class="indicator" data-v-8b85607e></div><a class="VPLink link link" href="/EMGFlow-Python-Package/reference/outlier-detection.html" data-v-8b85607e><!--[--><p class="text" data-v-8b85607e>Outlier detection</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8b85607e data-v-8b85607e><div class="item" data-v-8b85607e><div class="indicator" data-v-8b85607e></div><a class="VPLink link link" href="/EMGFlow-Python-Package/reference/file-access.html" data-v-8b85607e><!--[--><p class="text" data-v-8b85607e>File access</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-8e2b8225><section class="VPSidebarItem level-0" data-v-8e2b8225 data-v-8b85607e><div class="item" role="button" tabindex="0" data-v-8b85607e><div class="indicator" data-v-8b85607e></div><h2 class="text" data-v-8b85607e>About Us</h2><!----></div><div class="items" data-v-8b85607e><!--[--><div class="VPSidebarItem level-1 is-link" data-v-8b85607e data-v-8b85607e><div class="item" data-v-8b85607e><div class="indicator" data-v-8b85607e></div><a class="VPLink link link" href="/EMGFlow-Python-Package/about/authors.html" data-v-8b85607e><!--[--><p class="text" data-v-8b85607e>Authors</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8b85607e data-v-8b85607e><div class="item" data-v-8b85607e><div class="indicator" data-v-8b85607e></div><a class="VPLink link link" href="/EMGFlow-Python-Package/about/citation.html" data-v-8b85607e><!--[--><p class="text" data-v-8b85607e>Citation</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-8b85607e data-v-8b85607e><div class="item" data-v-8b85607e><div class="indicator" data-v-8b85607e></div><a class="VPLink link link" href="/EMGFlow-Python-Package/about/contact.html" data-v-8b85607e><!--[--><p class="text" data-v-8b85607e>Contact us</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-d8d3e66f data-v-6a411d75><div class="VPDoc has-sidebar has-aside" data-v-6a411d75 data-v-5e576dee><!--[--><!--]--><div class="container" data-v-5e576dee><div class="aside" data-v-5e576dee><div class="aside-curtain" data-v-5e576dee></div><div class="aside-container" data-v-5e576dee><div class="aside-content" data-v-5e576dee><div class="VPDocAside" data-v-5e576dee data-v-8e8afcfb><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-8e8afcfb data-v-f2249f6d><div class="content" data-v-f2249f6d><div class="outline-marker" data-v-f2249f6d></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-f2249f6d>On this page</div><ul class="VPDocOutlineItem root" data-v-f2249f6d data-v-e7c3772a><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-8e8afcfb></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-5e576dee><div class="content-container" data-v-5e576dee><!--[--><!--]--><main class="main" data-v-5e576dee><div style="position:relative;" class="vp-doc _EMGFlow-Python-Package_reference_feature-extraction" data-v-5e576dee><div><h1 id="extractfeatures-module-documentation" tabindex="-1"><code>ExtractFeatures</code> Module Documentation <a class="header-anchor" href="#extractfeatures-module-documentation" aria-label="Permalink to &quot;`ExtractFeatures` Module Documentation&quot;">​</a></h1><p>This module takes preprocessed data, and extracts features from the sEMG signal that capture information in both time and frequency domains. The main function to do this is <code>ExtractFeatures</code>. Within this call, individual features are calculated by their own functions, allowing them to be incorporated into your own workflow.</p><hr><h2 id="basic-time-series-statistics" tabindex="-1">Basic Time-Series Statistics <a class="header-anchor" href="#basic-time-series-statistics" aria-label="Permalink to &quot;Basic Time-Series Statistics&quot;">​</a></h2><p>The <code>AnalyzeSignal</code> function calculates some basic statistics that don&#39;t involve their own functions. This includes:</p><ul><li>Minimum voltage</li><li>Maximum voltage</li><li>Mean voltage</li><li>Standard deviation of voltage</li><li>Skew of voltage</li><li>Kurtosis of voltage</li><li>Maximum frequency</li></ul><p>The values returned will be a voltage equivalent to the units used in the data provided.</p><p>Most of these are commonly understood concepts:</p><ul><li><strong>Minimum</strong> is calculated with <code>np.min</code></li><li><strong>Maximum</strong> is calculated with <code>np.max</code></li><li><strong>Mean</strong> is calculated with <code>np.mean</code></li><li><strong>Standard Deviation</strong> is calculated with <code>np.std</code></li></ul><p>Skew and kurtosis are lesser known statistical measurements.</p><h3 id="skew" tabindex="-1">Skew <a class="header-anchor" href="#skew" aria-label="Permalink to &quot;Skew&quot;">​</a></h3><p>Skewness describes the symmetry of a dataset, considered more skewed the less symmetrical the left and right distributions of the median are.</p><p>Skew is calculated as follows:</p><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>s=\frac{\frac{\mu-M\\_o}{\sigma}}{\frac{3(\mu-M\\_d)}{\sigma}}</span></span></code></pre></div><ul><li>$\mu$ &lt;-- Mean</li><li>$\sigma$ &lt;-- Standard deviation</li><li>$M_o$ &lt;-- Mode</li><li>$M_d$ &lt;-- Median</li></ul><p><strong>Skew</strong> is calculated with <code>scipy.stats.skew</code></p><h3 id="kurtosis" tabindex="-1">Kurtosis <a class="header-anchor" href="#kurtosis" aria-label="Permalink to &quot;Kurtosis&quot;">​</a></h3><p>Kurtosis describes the amount of data in the tails of a bell curve of a distribution.</p><p>Kurtosis is calculated as follows:</p><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>k=\frac{1}{N}\sum\\_{i=1}^N\left(\frac{x\\_i-\mu}{\sigma}\right)^4</span></span></code></pre></div><ul><li>$\mu$ &lt;-- Mean</li><li>$\sigma$ &lt;-- Standard deviation</li><li>$N$ &lt;-- Number of data points</li></ul><p><strong>Kurtosis</strong> is calculated with <code>scipy.stats.kurtosis</code></p><hr><h2 id="calciemg" tabindex="-1"><code>CalcIEMG</code> <a class="header-anchor" href="#calciemg" aria-label="Permalink to &quot;`CalcIEMG`&quot;">​</a></h2><p><strong>Description</strong></p><p>Calculates the Integrated EMG (IEMG) of the signal. The IEMG measures the area under the curve of the signal, which can provide useful information about muscle activity. In an EMG signal, the IEMG describes when the muscle begins contracting, and is related to the signal sequence firing point (Phinyomark et al., 2009).</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CalcIEMG(Signal, col, sr)</span></span></code></pre></div><p><strong>Theory</strong></p><p>In the reference, the IEMG does not account for the sampling rate. Two signal recordings with the same shape but different sampling rate would have different results since we are integrating with respect to time. As such, the calculation made here will include multiplying by sampling rate.</p><p>The IEMG is calculated as follows:</p><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\text{IEMG}=s\\_r\sum\\_{i=1}^N|x\\_i|</span></span></code></pre></div><ul><li>$s_r$ &lt;-- Sampling rate</li><li>$N$ &lt;-- Number of data points</li></ul><p>(Spiewak et al., 2018)</p><p><strong>Parameters</strong></p><p><code>Signal</code>: pd.DataFrame</p><ul><li>Should have one column called &quot;<code>Time</code>&quot; for the time indexes, and other named columns for the values at those times.</li></ul><p><code>col</code>: str</p><ul><li>String name of a column in <code>Signal</code> the filters are being applied to.</li></ul><p><code>sr</code>: int/float</p><ul><li>Numerical value of the sampling rate of the <code>Signal</code>. This is the number of entries recorded per second, or the inverse of the difference in time between entries.</li></ul><p><strong>Returns</strong></p><p><code>CalcIEMG</code>: float</p><ul><li>Returns the value of the IEMG.</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>col</code> is not found in <code>Signal</code>.</p><p>Raises an error if <code>sr</code> is less or equal to 0.</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Calculate the IEMG of SignalDF, for column &#39;column1&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">IEMG</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.CalcIEMG(SignalDF, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;column1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><hr><h2 id="calcmav" tabindex="-1"><code>CalcMAV</code> <a class="header-anchor" href="#calcmav" aria-label="Permalink to &quot;`CalcMAV`&quot;">​</a></h2><p><strong>Description</strong></p><p>Calculates the Mean Absolute Value (MAV) of the signal. In an EMG signal, the MAV describes the muscle contraction level (Phinyomark et al., 2009).</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CalcMAV(Signal, col)</span></span></code></pre></div><p><strong>Theory</strong></p><p>The MAV is calculated as follows:</p><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\text{MAV}=\frac{1}{N}\sum\\_{i=1}^N|x\\_i|</span></span></code></pre></div><ul><li>$N$ &lt;-- Number of data points</li></ul><p>(Tkach et al., 2010)</p><p><strong>Parameters</strong></p><p><code>Signal</code>: pd.DataFrame</p><ul><li>Should have one column called &quot;<code>Time</code>&quot; for the time indexes, and other named columns for the values at those times.</li></ul><p><code>col</code>: str</p><ul><li>String name of a column in <code>Signal</code> the filters are being applied to.</li></ul><p><strong>Returns</strong></p><p><code>CalcMAV</code>: float</p><ul><li>Returns the value of the MAV.</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>col</code> is not found in <code>Signal</code>.</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Calculate the MAV of SignalDF, for column &#39;column1&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MAV</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.CalcMAV(SignalDF, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;column1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><hr><h2 id="calcmmav" tabindex="-1"><code>CalcMMAV</code> <a class="header-anchor" href="#calcmmav" aria-label="Permalink to &quot;`CalcMMAV`&quot;">​</a></h2><p><strong>Description</strong></p><p>Calculates the Modified Mean Absolute Value (MMAV) of the signal. The MMAV is an alteration of MAV that gives more weight to values in the middle of the signal to reduce error from the beginning and end of the signal.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CalcMMAV(Signal, col)</span></span></code></pre></div><p><strong>Theory</strong></p><p>The MMAV is identical to MAV, except it introduces a weight to the calculation. Values are given a weight of 1 when they are between the 25th and 74th percentile, and 0.5 outside. The article describing the MMAV also listed another modification, MMAV2, but the description appeared to be flawed, and as such the measure was not included.</p><p>The MMAV is calculated as follows:</p><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\text{MMAV}=\frac{1}{N}\sum\\_{i=1}^N|x\\_iw\\_i|</span></span></code></pre></div><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>w\\_i=\left\{ \begin{matrix} 1 &amp; \text{if }0.25N\le n\le 0.75N \\\ 0.5 &amp; \text{otherwise} \end{matrix} \right.</span></span></code></pre></div><ul><li>$N$ &lt;-- Number of data points</li></ul><p>(Chowdhury et al., 2013)</p><p><strong>Parameters</strong></p><p><code>Signal</code>: pd.DataFrame</p><ul><li>Should have one column called &quot;<code>Time</code>&quot; for the time indexes, and other named columns for the values at those times.</li></ul><p><code>col</code>: str</p><ul><li>String name of a column in <code>Signal</code> the filters are being applied to.</li></ul><p><strong>Returns</strong></p><p><code>CalcMMAV</code>: float</p><ul><li>Returns the value of the MMAV.</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>col</code> is not found in <code>Signal</code>.</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Calculate the MMAV of SignalDF, for column &#39;column1&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MMAV</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.CalcMMAV(SignalDF, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;column1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><hr><h2 id="calcssi" tabindex="-1"><code>CalcSSI</code> <a class="header-anchor" href="#calcssi" aria-label="Permalink to &quot;`CalcSSI`&quot;">​</a></h2><p><strong>Description</strong></p><p>Calculates the Simple Square Integral (SSI) of the signal. In an EMG signal, the SSI describes the energy of the signal (Phinyomark et al., 2009).</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CalcSSI(Signal, col, sr)</span></span></code></pre></div><p><strong>Theory</strong></p><p>In the reference, the SSI does not account for the sampling rate. Two signal recordings with the same shape but different sampling rate would have different results since we are integrating with respect to time. As such, the calculation made here will include multiplying by sampling rate.</p><p>The SSI is calculated as follows:</p><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\text{SSI}=s\\_r^2\sum\\_{i=1}^N|x\\_i|^2</span></span></code></pre></div><ul><li>$s_r$ &lt;-- Sampling rate</li><li>$N$ &lt;-- Number of data points</li></ul><p>(Spiewak et al., 2018)</p><p><strong>Parameters</strong></p><p><code>Signal</code>: pd.DataFrame</p><ul><li>Should have one column called &quot;<code>Time</code>&quot; for the time indexes, and other named columns for the values at those times.</li></ul><p><code>col</code>: str</p><ul><li>String name of a column in <code>Signal</code> the filters are being applied to.</li></ul><p><code>sr</code>: int/float</p><ul><li>Numerical value of the sampling rate of the <code>Signal</code>. This is the number of entries recorded per second, or the inverse of the difference in time between entries.</li></ul><p><strong>Returns</strong></p><p><code>CalcSSI</code>: float</p><ul><li>Returns the value of the SSI.</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>col</code> is not found in <code>Signal</code>.</p><p>Raises an error if <code>sr</code> is less or equal to 0</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Calculate the SSI of SignalDF, for column &#39;column1&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SSI</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.CalcSSI(SignalDF, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;column1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><hr><h2 id="calcvar" tabindex="-1"><code>CalcVAR</code> <a class="header-anchor" href="#calcvar" aria-label="Permalink to &quot;`CalcVAR`&quot;">​</a></h2><p><strong>Description</strong></p><p>Calculates the Variance (VAR) of the signal. In an EMG signal, the VAR describes the power of the signal (Phinyomark et al., 2009).</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CalcVAR(Signal, col)</span></span></code></pre></div><p><strong>Theory</strong></p><p>The VAR is calculated as follows:</p><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\text{VAR}=\frac{1}{N-1}\sum\\_{i=1}^Nx\\_i^2</span></span></code></pre></div><p>(Spiewak et al., 2018)</p><p><strong>Parameters</strong></p><p><code>Signal</code>: pd.DataFrame</p><ul><li>Should have one column called &quot;<code>Time</code>&quot; for the time indexes, and other named columns for the values at those times.</li></ul><p><code>col</code>: str</p><ul><li>String name of a column in <code>Signal</code> the filters are being applied to.</li></ul><p><strong>Returns</strong></p><p><code>CalcVAR</code>: float</p><ul><li>Returns the value of the VAR.</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>col</code> is not found in <code>Signal</code>.</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Calculate the VAR of SignalDF, for column &#39;column1&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">VAR</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.CalcVAR(SignalDF, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;column1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><hr><h2 id="calcvorder" tabindex="-1"><code>CalcVOrder</code> <a class="header-anchor" href="#calcvorder" aria-label="Permalink to &quot;`CalcVOrder`&quot;">​</a></h2><p><strong>Description</strong></p><p>Calculates the V-Order of a signal. The V-Order is an alteration of VAR that takes the square root of the result.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CalcVOrder(Signal, col)</span></span></code></pre></div><p><strong>Theory</strong></p><p>The V-Order is calculated using the $v$-operator, essentially working like a Euclidean distance to the $v$th order. One study indicates that the best value for $v$ is 2, meaning the V-Order is just the square root of the VAR feature.</p><p>The V-Order is calculated as follows:</p><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\text{vORDER}=\sqrt{\text{VAR}}</span></span></code></pre></div><p>(Tkach et al., 2010)</p><p><strong>Parameters</strong></p><p><code>Signal</code>: pd.DataFrame</p><ul><li>Should have one column called &quot;<code>Time</code>&quot; for the time indexes, and other named columns for the values at those times.</li></ul><p><code>col</code>: str</p><ul><li>String name of a column in <code>Signal</code> the filters are being applied to.</li></ul><p><strong>Returns</strong></p><p><code>CalcVOrder</code>: float</p><ul><li>Returns the value of the V-Order.</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>col</code> is not found in <code>Signal</code>.</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Calculate the V-Order of SignalDF, for column &#39;column1&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">VOrder </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.CalcVOrder(SignalDF, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;column1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><hr><h2 id="calcrms" tabindex="-1"><code>CalcRMS</code> <a class="header-anchor" href="#calcrms" aria-label="Permalink to &quot;`CalcRMS`&quot;">​</a></h2><p><strong>Description</strong></p><p>Calculates the Root Mean Square (RMS) of a signal. In an EMG signal, the RMS provides information about the constant force, and non-fatiguing contractions of the muscles (Phinyomark et al., 2009).</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CalcRMS(Signal, col)</span></span></code></pre></div><p><strong>Theory</strong></p><p>The RMS is calculated as follows:</p><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\text{RMS}=\sqrt{\frac{1}{N}\sum\\_{i=1}^N|x\\_i|^2}</span></span></code></pre></div><ul><li>$N$ &lt;-- Number of data points</li></ul><p>(Spiewak et al., 2018)</p><p><strong>Parameters</strong></p><p><code>Signal</code>: pd.DataFrame</p><ul><li>Should have one column called &quot;<code>Time</code>&quot; for the time indexes, and other named columns for the values at those times.</li></ul><p><code>col</code>: str</p><ul><li>String name of a column in <code>Signal</code> the filters are being applied to.</li></ul><p><strong>Returns</strong></p><p><code>CalcRMS</code>: float</p><ul><li>Returns the value of the RMS.</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>col</code> is not found in <code>Signal</code>.</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Calculate the RMS of SignalDF, for column &#39;column1&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RMS</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.CalcRMS(SignalDF, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;column1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><hr><h2 id="calcwl" tabindex="-1"><code>CalcWL</code> <a class="header-anchor" href="#calcwl" aria-label="Permalink to &quot;`CalcWL`&quot;">​</a></h2><p><strong>Description</strong></p><p>Calculates the Waveform Length (WL) of a signal. The WL provides information about the amplitude, frequency, and duration of the signal.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CalcWL(Signal, col)</span></span></code></pre></div><p><strong>Theory</strong></p><p>The WL is calculated as follows:</p><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\text{WL}=\sum\\_{i=1}^{N-1}|x\\_{i+1}-x\\_i|</span></span></code></pre></div><ul><li>$N$ &lt;-- Number of data points</li></ul><p>(Spiewak et al., 2018)</p><p><strong>Parameters</strong></p><p><code>Signal</code>: pd.DataFrame</p><ul><li>Should have one column called &quot;<code>Time</code>&quot; for the time indexes, and other named columns for the values at those times.</li></ul><p><code>col</code>: str</p><ul><li>String name of a column in <code>Signal</code> the filters are being applied to.</li></ul><p><strong>Returns</strong></p><p><code>CalcWL</code>: float</p><ul><li>Returns the value of the WL.</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>col</code> is not found in <code>Signal</code>.</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Calculate the WL of SignalDF, for column &#39;column1&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">WL</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.CalcWL(SignalDF, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;column1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><hr><h2 id="calcwamp" tabindex="-1"><code>CalcWAMP</code> <a class="header-anchor" href="#calcwamp" aria-label="Permalink to &quot;`CalcWAMP`&quot;">​</a></h2><p><strong>Description</strong></p><p>Calculate the Willison Amplitude (WAMP) of a signal. The WAMP measures the number of times an EMG amplitude exceeds a given threshold. In an EMG signal, the WAMP describes the firing of Motor Unit Action Potentials (MUAP), and muscle contraction level (Phinyomark et al., 2009).</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CalcWAMP(Signal, col, threshold)</span></span></code></pre></div><p><strong>Theory</strong></p><p>Thresholds for the WAMP are commonly chosen within the 50-100 mV range. The WAMP counts the number of recorded times in the signal that the charge is greater than the threshold, so it can be affected by the sampling rate. If datasets with different sampling rates are being compared, it may be beneficial to normalize each result by the length of the signal.</p><p>When choosing a value, pass it in terms of the same units being used in the data.</p><p>The WAMP is calculated as follows:</p><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\text{WAMP}=\sum\\_{i=1}^{N-1}f(|x\\_{i+1}-x\\_i|)</span></span></code></pre></div><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>f(x)=\left\{\begin{matrix} 1 &amp; \text{if }x&gt;\epsilon \\\ 0 &amp; \text{otherwise} \end{matrix}\right.</span></span></code></pre></div><ul><li>$N$ &lt;-- Number of data points</li><li>$\epsilon$ &lt;-- Voltage change threshold</li></ul><p>(Tkach et al., 2010)</p><p><strong>Parameters</strong></p><p><code>Signal</code>: pd.DataFrame</p><ul><li>Should have one column called &quot;<code>Time</code>&quot; for the time indexes, and other named columns for the values at those times.</li></ul><p><code>col</code>: str</p><ul><li>String name of a column in <code>Signal</code> the filters are being applied to.</li></ul><p><code>threshold</code>: float</p><ul><li>Voltage threshold for the WAMP.</li></ul><p><strong>Returns</strong></p><p><code>CalcWAMP</code>: int</p><ul><li>Returns the value of the WAMP.</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>col</code> is not found in <code>Signal</code>.</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Calculate the WL of SignalDF, for column &#39;column1&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">WAMP</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.CalcWAMP(SignalDF, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;column1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">55</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><hr><h2 id="calclog" tabindex="-1"><code>CalcLOG</code> <a class="header-anchor" href="#calclog" aria-label="Permalink to &quot;`CalcLOG`&quot;">​</a></h2><p><strong>Description</strong></p><p>Calculates the Log-Detector (LOG) of a signal. The LOG provides an estimate of the force exerted by the muscle.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CalcLOG(Signal, col)</span></span></code></pre></div><p><strong>Theory</strong></p><p>The LOG is calculated as follows:</p><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\text{LOG}=e^{\frac{1}{N}\sum\\_{i=1}^N\log(|x\\_k|)}</span></span></code></pre></div><ul><li>$N$ &lt;-- Number of data points</li></ul><p>(Tkach et al., 2010)</p><p><strong>Parameters</strong></p><p><code>Signal</code>: pd.DataFrame</p><ul><li>Should have one column called &quot;<code>Time</code>&quot; for the time indexes, and other named columns for the values at those times.</li></ul><p><code>col</code>: str</p><ul><li>String name of a column in <code>Signal</code> the filters are being applied to.</li></ul><p><strong>Returns</strong></p><p><code>CalcLOG</code>: float</p><ul><li>Returns the value of the LOG.</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>col</code> is not found in <code>Signal</code>.</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Calculate the LOG of SignalDF, for column &#39;column1&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LOG</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.CalcLOG(SignalDF, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;column1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><hr><h2 id="calcmfl" tabindex="-1"><code>CalcMFL</code> <a class="header-anchor" href="#calcmfl" aria-label="Permalink to &quot;`CalcMFL`&quot;">​</a></h2><p><strong>Description</strong></p><p>Calculates the Maximum Fractal Length (MFL) of a signal. The MFL measures the activation of low-level muscle contractions.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CalcMFL(Signal, col)</span></span></code></pre></div><p><strong>Theory</strong></p><p>The MFL is calculated as follows:</p><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\text{MFL}=\log\left(\sqrt{\sum\\_{i=1}^{N-1}(x\\_{i+1}-x\\_i)^2}\right)</span></span></code></pre></div><ul><li>$N$ &lt;-- Number of data points</li></ul><p>(Too et al., 2019)</p><p><strong>Parameters</strong></p><p><code>Signal</code>: pd.DataFrame</p><ul><li>Should have one column called &quot;<code>Time</code>&quot; for the time indexes, and other named columns for the values at those times.</li></ul><p><code>col</code>: str</p><ul><li>String name of a column in <code>Signal</code> the filters are being applied to.</li></ul><p><strong>Returns</strong></p><p><code>CalcMFL</code>: float</p><ul><li>Returns the value of the MFL.</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>col</code> is not found in <code>Signal</code>.</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Calculate the MFL of SignalDF, for column &#39;column1&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MFL</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.CalcMFL(SignalDF, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;column1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><hr><h2 id="calcap" tabindex="-1"><code>CalcAP</code> <a class="header-anchor" href="#calcap" aria-label="Permalink to &quot;`CalcAP`&quot;">​</a></h2><p><strong>Description</strong></p><p>Calculates the Average Power (AP) of a signal. The AP measures the energy distribution of the signal.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CalcAP(Signal, col)</span></span></code></pre></div><p><strong>Theory</strong></p><p>The AP is calculated as follows:</p><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\text{AP}=\frac{1}{N}\sum\\_{i=1}^Nx\\_i^2</span></span></code></pre></div><ul><li>$N$ &lt;-- Number of data points</li></ul><p>(Too et al., 2019)</p><p><strong>Parameters</strong></p><p><code>Signal</code>: pd.DataFrame</p><ul><li>Should have one column called &quot;<code>Time</code>&quot; for the time indexes, and other named columns for the values at those times.</li></ul><p><code>col</code>: str</p><ul><li>String name of a column in <code>Signal</code> the filters are being applied to.</li></ul><p><strong>Returns</strong></p><p><code>CalcAP</code>: float</p><ul><li>Returns the value of the AP.</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>col</code> is not found in <code>Signal</code>.</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Calculate the AP of SignalDF, for column &#39;column1&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AP</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.CalcMFL(SignalDF, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;column1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><hr><h2 id="calcspecflux" tabindex="-1"><code>CalcSpecFlux</code> <a class="header-anchor" href="#calcspecflux" aria-label="Permalink to &quot;`CalcSpecFlux`&quot;">​</a></h2><p><strong>Description</strong></p><p>Calculates the Spectral Flux of a signal. Spectral Flux measures the change in spectrums between two signals, or two sections of a signal.</p><p><code>CalcSpecFlux</code> behaves differently, depending on if it is given a Pandas DataFrame or float. Providing a DataFrame treats the dataframe as a new signal, and finds the spectral flux between them. Providing a float $n$ will provide the spectral flux between the first $n$% of the signal, and the second $n-1$% of the signal.</p><p>The call to <code>CalcSpecFlux</code> within <code>AnalyzeSignals</code> uses a default value of <code>diff=0.5</code>.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CalcSpecFlux(Signal1, diff, col, sr, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">diff_sr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">None</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>Theory</strong></p><p>Spectral Flux is used to compare two different signals together. The applications of this are more difficult to implement, so there is no one function to handle this.</p><p>Spectral Flux is calculated as follows:</p><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\text{FL}\\_{i,i-1}=\sum\\_{k=1}^{Wf\\_L}(\text{EN}\\_i(k)-\text{EN}\\_{i-1}(k))^2</span></span></code></pre></div><p>(Giannakopoulos &amp; Pikrakis, 2014)</p><p><strong>Parameters</strong></p><p><code>Signal1</code>: pd.DataFrame</p><ul><li>Should have one column called &quot;<code>Time</code>&quot; for the time indexes, and other named columns for the values at those times.</li></ul><p><code>diff</code>: pd.DataFrame, float</p><ul><li>Either a new signal DataFrame, or a decimal indicating the percentage of the signal to split.</li></ul><p><code>col</code>: str</p><ul><li>String name of a column in <code>Signal</code> the filters are being applied to.</li></ul><p><code>sr</code>: int/float</p><ul><li>Numerical value of the sampling rate of the <code>Signal</code>. This is the number of entries recorded per second, or the inverse of the difference in time between entries.</li></ul><p><code>diff_sr</code>: int/float (None)</p><ul><li>Sampling rate of <code>diff</code> if it has a different sampling rate than the first signal. If left None, will assume both signals are using the same sampling rate.</li></ul><p><strong>Returns</strong></p><p><code>CalcSpecFlux</code>: float</p><ul><li>Returns the value of the Spectral Flux.</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>col</code> is not found in <code>Signal</code>.</p><p>Raises an error is <code>sr</code> is less or equal to 0.</p><p>Raises an error if <code>diff</code> is a float and not between 0 and 1.</p><p>Raises an error if <code>diff</code> is a data frame and does not contain a column <code>col</code>.</p><p>Raises an error if <code>diff_sr</code> is less or equal to 0.</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Calculate the Spectral Flux of Signal1DF, for column &#39;column1&#39;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AP</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.CalcSpecFlux(Signal1DF, Signal2DF, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;column1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><hr><h2 id="calcmdf" tabindex="-1">CalcMDF <a class="header-anchor" href="#calcmdf" aria-label="Permalink to &quot;CalcMDF&quot;">​</a></h2><p><strong>Description</strong></p><p>Calculates the Median Frequency (MDF) of a Signal.</p><p><strong>Theory</strong></p><p>MDF is the frequency on the power spectrum that can divide it into two regions of equal total power.</p><p>Since it may not be possible to perfectly divide the spectrum into two regions of exactly equal power, this function finds the frequency that divides it the best.</p><p><strong>Parameters</strong></p><p><code>psd</code>: pd.DataFrame</p><ul><li>Normalized PSD of a signal. Should have a &quot;frequency&quot; and &quot;power&quot; column.</li></ul><p><strong>Returns</strong></p><p><code>CalcMDF</code>: float</p><ul><li>Returns the frequency of the MDF.</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>psd</code> does not only have columns &#39;Frequency&#39; and &#39;Power&#39;.</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Calculate the MDF of SignalDF, for column &#39;column1&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">psd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.EMG2PSD(SignalDF[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;column1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MDF</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.CalcMDF(psd)</span></span></code></pre></div><hr><h2 id="calcmnf" tabindex="-1">CalcMNF <a class="header-anchor" href="#calcmnf" aria-label="Permalink to &quot;CalcMNF&quot;">​</a></h2><p><strong>Description</strong></p><p>Calculates the Mean Frequency (MNF) of a Signal.</p><p><strong>Theory</strong></p><p>MNF is the mean frequency on the power spectrum, weighted by the power of each frequency.</p><p>MNF is calculated as follows:</p><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\text{MNF}=\frac{\sum\\_i^N f\\_ip\\_i}{\sum\\_i^N p\\_i}$$</span></span></code></pre></div><p>(Phinyomark et al., 2009)</p><p><strong>Parameters</strong></p><p><code>psd</code>: pd.DataFrame</p><ul><li>Normalized PSD of a signal. Should have a &quot;frequency&quot; and &quot;power&quot; column.</li></ul><p><strong>Returns</strong></p><p><code>CalcMDF</code>: float</p><ul><li>Returns the frequency of the MNF.</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>psd</code> does not only have columns &#39;Frequency&#39; and &#39;Power&#39;.</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Calculate the MNF of SignalDF, for column &#39;column1&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">psd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.EMG2PSD(SignalDF[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;column1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MNF</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.CalcMNF(psd)</span></span></code></pre></div><hr><h2 id="calctwitchratio" tabindex="-1"><code>CalcTwitchRatio</code> <a class="header-anchor" href="#calctwitchratio" aria-label="Permalink to &quot;`CalcTwitchRatio`&quot;">​</a></h2><p><strong>Description</strong></p><p>Calculates the Twitch Ratio of a Signal based on its power distribution.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CalcTwitchRatio(psd, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">freq</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">60</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>Theory</strong></p><p>This metric uses a proposed muscle separation theory put forward by this project. This measure is typically used in audio feature extraction, separating the high and low frequencies. This kind of separation is not typically done in EMG feature extraction. However, literature suggests that there are both high and low frequency muscle activations that can be separated by an approximately 60Hz threshold (Hegedus et al., 2020). Since these muscles are present in the face (McComas, 1998), this experimental feature is being added by applying this audio feature in a new context.</p><p>Twitch Ratio is an adaptation of Alpha Ratio (Eyben et al., 2016).</p><p>Twitch Ratio is calculated as follows:</p><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\text{TR}=\frac{\sum\\_{i=f\\_0}^{f\\_t} p\\_i}{\sum\\_{i=f\\_t}^{f\\_N}p\\_i}</span></span></code></pre></div><ul><li>$p_i$ &lt;-- Power of normalized PSD at frequency $i$</li><li>$f_0$ &lt;-- Minimum frequency of the PSD</li><li>$f_t$ &lt;-- Threshold frequency of the PSD</li><li>$f_N$ &lt;-- Maximum frequency of the PSD</li></ul><p><strong>Parameters</strong></p><p><code>psd</code>: pd.DataFrame</p><ul><li>Normalized PSD of a signal. Should have a &quot;frequency&quot; and &quot;power&quot; column.</li></ul><p><code>freq</code>: int/float (60Hz)</p><ul><li>Frequency threshold of the calculation. Defaults to 60Hz, as that is the theorized frequency threshold between slow-twitching and fast-twitching muscles.</li></ul><p><strong>Returns</strong></p><p><code>CalcTwitchRatio</code>: float</p><ul><li>Returns the value of the Twitch Ratio.</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>freq</code> is less or equal to 0.</p><p>Raises an error if <code>psd</code> does not only have columns &#39;Frequency&#39; and &#39;Power&#39;.</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Calculate the Twitch Ratio of SignalDF, for column &#39;column1&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">psd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.EMG2PSD(SignalDF[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;column1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TR</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.CalcTwitchRatio(psd)</span></span></code></pre></div><hr><h2 id="calctwitchindex" tabindex="-1"><code>CalcTwitchIndex</code> <a class="header-anchor" href="#calctwitchindex" aria-label="Permalink to &quot;`CalcTwitchIndex`&quot;">​</a></h2><p><strong>Description</strong></p><p>Calculates the Twitch Index of a Signal based on its power distribution.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CalcTwitchIndex(psd, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">freq</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">60</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>Theory</strong></p><p>This metric uses a proposed muscle separation theory put forward by this project. This measure is typically used in audio feature extraction, separating the high and low frequencies. This kind of separation is not typically done in EMG feature extraction. However, literature suggests that there are both high and low frequency muscle activations (slow twitching muscles, and fast twitching muscles) that can be separated by an approximately 60Hz threshold. As such, this experimental feature is being added by applying this audio feature in a new context.</p><p>Twitch Index is an adaptation of the Hammarberg index (Eyben et al., 2016).</p><p>Twitch Index is calculated as follows:</p><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\text{TR}=\frac{\max\left(\sum\\_{i=f\\_0}^{f\\_t} p\\_i\right)}{\max\left(\sum\\_{i=f\\_t}^{f\\_N}p\\_i\right)}</span></span></code></pre></div><ul><li>$p_i$ &lt;-- Power of normalized PSD at frequency $i$</li><li>$f_0$ &lt;-- Minimum frequency of the PSD</li><li>$f_t$ &lt;-- Threshold frequency of the PSD</li><li>$f_N$ &lt;-- Maximum frequency of the PSD</li></ul><p><strong>Parameters</strong></p><p><code>psd</code>: pd.DataFrame</p><ul><li>Normalized PSD of a signal. Should have a &quot;frequency&quot; and &quot;power&quot; column.</li></ul><p><code>freq</code>: int/float (60Hz)</p><ul><li>Frequency threshold of the calculation. Defaults to 60Hz, as that is the theorized frequency threshold between slow-twitching and fast-twitching muscles.</li></ul><p><strong>Returns</strong></p><p><code>CalcTwitchRatio</code>: float</p><ul><li>Returns the value of the Twitch Ratio</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>freq</code> is less or equal to 0.</p><p>Raises an error if <code>psd</code> does not only have columns &#39;Frequency&#39; and &#39;Power&#39;.</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Calculate the Twitch Index of SignalDF, for column &#39;column1&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">psd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.EMG2PSD(SignalDF[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;column1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TI</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.CalcTwitchIndex(psd)</span></span></code></pre></div><hr><h2 id="calctwitchslope" tabindex="-1"><code>CalcTwitchSlope</code> <a class="header-anchor" href="#calctwitchslope" aria-label="Permalink to &quot;`CalcTwitchSlope`&quot;">​</a></h2><p><strong>Description</strong></p><p>Calculates the Twitch Slope of a Signal based on its power distribution.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CalcTwitchIndex(psd, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">freq</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">60</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>Theory</strong></p><p>This metric uses a proposed muscle separation theory put forward by this project. This measure is typically used in audio feature extraction, separating the high and low frequencies. This kind of separation is not typically done in EMG feature extraction. However, literature suggests that there are both high and low frequency muscle activations (slow twitching muscles, and fast twitching muscles) that can be separated by an approximately 60Hz threshold. As such, this experimental feature is being added by applying this audio feature in a new context.</p><p>Twitch Slope is an adaptation of spectral slope (Eyben et al., 2016).</p><p><code>CalcTwitchSlope</code> uses the <code>np.linalg.lstsq</code> to find the slope of the line of best fit for the two regions separated by frequency, and returns both values.</p><p><strong>Parameters</strong></p><p><code>psd</code>: pd.DataFrame</p><ul><li>Normalized PSD of a signal. Should have a &quot;frequency&quot; and &quot;power&quot; column.</li></ul><p><code>freq</code>: int/float (60Hz)</p><ul><li>Frequency threshold of the calculation. Defaults to 60Hz, as that is the theorized frequency threshold between slow-twitching and fast-twitching muscles.</li></ul><p><strong>Returns</strong></p><p><code>CalcTwitchSlope</code>: float, float</p><ul><li>Returns both of the values of the Twitch Ratio.</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>freq</code> is less or equal to 0.</p><p>Raises an error if <code>psd</code> does not only have columns &#39;Frequency&#39; and &#39;Power&#39;.</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Calculate the Twitch Index of SignalDF, for column &#39;column1&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">psd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.EMG2PSD(SignalDF[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;column1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TS_Fast</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">TS_Slow</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.CalcTwitchSlope(psd)</span></span></code></pre></div><hr><h2 id="calcsc" tabindex="-1"><code>CalcSC</code> <a class="header-anchor" href="#calcsc" aria-label="Permalink to &quot;`CalcSC`&quot;">​</a></h2><p><strong>Description</strong></p><p>Calculates the Spectral Centroid (SC) of a signal. The SC is the &quot;center of mass&quot; of a signal after a Fourier transform is applied.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CalcSC(psd)</span></span></code></pre></div><p><strong>Theory</strong></p><p>SC is calculated as follows:</p><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\text{SC}=\frac{\sum\\_{i=f\\_0}^{f\\_N}i\cdot p\\_i}{\sum\\_{i=f\\_0}^{f\\_N} p\\_i}</span></span></code></pre></div><ul><li>$p_i$ &lt;-- Power of normalized PSD at frequency $i$</li><li>$f_0$ &lt;-- Minimum frequency of the PSD</li><li>$f_N$ &lt;-- Maximum frequency of the PSD</li></ul><p>(Roldán Jiménez et al., 2019)</p><p><strong>Parameters</strong></p><p><code>psd</code>: pd.DataFrame</p><ul><li>Normalized PSD of a signal. Should have a &quot;frequency&quot; and &quot;power&quot; column.</li></ul><p><strong>Returns</strong></p><p><code>CalcSC</code>: float</p><ul><li>Returns the value of the SC.</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>psd</code> does not only have columns &#39;Frequency&#39; and &#39;Power&#39;.</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Calculate the SC of SignalDF, for column &#39;column1&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">psd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (SignalDF[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;column1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SC</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.CalcSC(psd)</span></span></code></pre></div><hr><h2 id="calcsf" tabindex="-1"><code>CalcSF</code> <a class="header-anchor" href="#calcsf" aria-label="Permalink to &quot;`CalcSF`&quot;">​</a></h2><p><strong>Description</strong></p><p>Calculates the Spectral Flatness (SF) of a signal. The SF measures noise in the magnitude spectrum.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CalcSF(psd)</span></span></code></pre></div><p><strong>Theory</strong></p><p>SF is calculated as follows:</p><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\text{SF}=\frac{\prod\\_{i=0}^{N-1}|p\\_i|^{\frac{1}{N}}}{\frac{1}{N}\sum\\_{i=0}^{N-1}|p\\_i|}</span></span></code></pre></div><ul><li>$p_i$ &lt;-- $i$th element of PSD strength</li><li>$N$ &lt;-- Number of elements in PSD</li></ul><p>(Nagineni et al., 2018)</p><p><strong>Parameters</strong></p><p><code>psd</code>: pd.DataFrame</p><ul><li>Normalized PSD of a signal. Should have a &quot;frequency&quot; and &quot;power&quot; column.</li></ul><p><strong>Returns</strong></p><p><code>CalcSF</code>: float</p><ul><li>Returns the value of the SF.</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>psd</code> does not only have columns &#39;Frequency&#39; and &#39;Power&#39;.</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Calculate the SF of SignalDF, for column &#39;column1&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">psd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.EMG2PSD(SignalDF[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;column1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SC</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.CalcSF(psd)</span></span></code></pre></div><hr><h2 id="calcss" tabindex="-1"><code>CalcSS</code> <a class="header-anchor" href="#calcss" aria-label="Permalink to &quot;`CalcSS`&quot;">​</a></h2><p><strong>Description</strong></p><p>Calculates the Spectral Spread (SS) of a signal. SS is also called the &quot;instantaneous bandwidth&quot;, and measures the standard deviation around the SC.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CalcSS(psd)</span></span></code></pre></div><p><strong>Theory</strong></p><p>SS is calculated as follows:</p><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\text{SS}=\frac{\sum\\_{m=0}^{N-1}(m-\text{SC})^2 \cdot |X(m)|}{\sum\\_{m=0}^{N-1}</span></span>
<span class="line"><span>|X(m)|}</span></span></code></pre></div><p>(Nagineni et al., 2018)</p><p><strong>Parameters</strong></p><p><code>psd</code>: pd.DataFrame</p><ul><li>Normalized PSD of a signal. Should have a &quot;frequency&quot; and &quot;power&quot; column.</li></ul><p><strong>Returns</strong></p><p><code>CalcSS</code>: float</p><ul><li>Returns the value of the SS.</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>psd</code> does not only have columns &#39;Frequency&#39; and &#39;Power&#39;.</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Calculate the SS of SignalDF, for column &#39;column1&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">psd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.EMG2PSD(SignalDF[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;column1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SS</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.CalcSS(psd)</span></span></code></pre></div><hr><h2 id="calcsdec" tabindex="-1"><code>CalcSDec</code> <a class="header-anchor" href="#calcsdec" aria-label="Permalink to &quot;`CalcSDec`&quot;">​</a></h2><p><strong>Description</strong></p><p>Calculates the Spectral Decrease (SDec) of a signal. SDec is the decrease of the slope of the spectrum with respect to frequency.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CalcSDec(psd)</span></span></code></pre></div><p><strong>Theory</strong></p><p>SDec is calculated as follows:</p><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\text{SDec}=\frac{\sum\\_{m=1}^{N-1}\frac{1}{N}(|X(m)|-|X(0)|)}{\sum\\_{m=1}^{N-1}|X(m)|}</span></span></code></pre></div><p>(Nagineni et al., 2018)</p><p><strong>Parameters</strong></p><p><code>psd</code>: pd.DataFrame</p><ul><li>Normalized PSD of a signal. Should have a &quot;frequency&quot; and &quot;power&quot; column.</li></ul><p><strong>Returns</strong></p><p><code>CalcSDec</code>: float</p><ul><li>Returns the value of the SDec.</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>psd</code> does not only have columns &#39;Frequency&#39; and &#39;Power&#39;.</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Calculate the SDec of SignalDF, for column &#39;column1&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">psd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.EMG2PSD(SignalDF[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;column1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SDec </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.CalcSDec(psd)</span></span></code></pre></div><hr><h2 id="calcsentropy" tabindex="-1"><code>CalcSEntropy</code> <a class="header-anchor" href="#calcsentropy" aria-label="Permalink to &quot;`CalcSEntropy`&quot;">​</a></h2><p><strong>Description</strong></p><p>Calculates the Spectral Entropy of a signal. Spectral Entropy is the Shannon entropy of the spectrum.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CalcSEntropy(psd)</span></span></code></pre></div><p><strong>Theory</strong></p><p>Spectral Entropy is calculated as follows:</p><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\text{Spectral Entropy}=-\sum\\_{i=1}^mp(dB\\_i)\log\\_2(p(dB\\_i))</span></span></code></pre></div><p>(Llanos et al., 2017)</p><p><strong>Parameters</strong></p><p><code>psd</code>: pd.DataFrame</p><ul><li>Normalized PSD of a signal. Should have a &quot;frequency&quot; and &quot;power&quot; column.</li></ul><p><strong>Returns</strong></p><p><code>CalcSEntropy</code>: float</p><ul><li>Returns the value of the SEntropy.</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>psd</code> does not only have columns &#39;Frequency&#39; and &#39;Power&#39;.</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Calculate the SEntropy of SignalDF, for column &#39;column1&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">psd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.EMG2PSD(SignalDF[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;column1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SEntropy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.CalcSEntropy(psd)</span></span></code></pre></div><hr><h2 id="calcsroll" tabindex="-1"><code>CalcSRoll</code> <a class="header-anchor" href="#calcsroll" aria-label="Permalink to &quot;`CalcSRoll`&quot;">​</a></h2><p><strong>Description</strong></p><p>Calculates the Spectral Rolloff (SRoll) of a signal. The spectral rolloff point is the frequency of the PSD where 85% of the total spectral energy lies below it.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CalcSRoll(psd, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">percent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.85</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>Theory</strong></p><p>The actual threshold for SRoll can be set manually, but literature suggests that 85% is the best point.</p><p>(Tjoa, 2022)</p><p><strong>Parameters</strong></p><p><code>psd</code>: pd.DataFrame</p><ul><li>Normalized PSD of a signal. Should have a &quot;frequency&quot; and &quot;power&quot; column.</li></ul><p><code>percent</code>: float</p><ul><li>Percentage threshold for SRoll.</li></ul><p><strong>Returns</strong></p><p><code>CalcSRoll</code>: float</p><ul><li>Returns the value of the SRoll.</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>psd</code> does not only have columns &#39;Frequency&#39; and &#39;Power&#39;.</p><p>Raises an error if <code>percent</code> is not between 0 and 1.</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Calculate the SRoll of SignalDF, for column &#39;column1&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">psd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.EMG2PSD(SignalDF[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;column1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SRoll </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.CalcSRoll(psd)</span></span></code></pre></div><hr><h2 id="calcsbw" tabindex="-1"><code>CalcSBW</code> <a class="header-anchor" href="#calcsbw" aria-label="Permalink to &quot;`CalcSBW`&quot;">​</a></h2><p><strong>Description</strong></p><p>Calculates the Spectral Bandwidth (SBW) of a signal. The SBW calculates the difference between the upper and lower freqencies in the frequency band.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CalcSBW(psd, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>Theory</strong></p><p>SBW has a parameter $p$ that can be adjusted to different values. Using a value of 2 will result in the standard deviation around the centroid.</p><p>SBW is calculated as follows:</p><div class="language-math vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">math</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>\text{SBW}=\left( \sum X(m)\cdot (m-\text{SC})^p \right)^{\frac{1}{p}}</span></span></code></pre></div><p>(Tjoa, 2022)</p><p><strong>Parameters</strong></p><p><code>psd</code>: pd.DataFrame</p><ul><li>Normalized PSD of a signal. Should have a &quot;frequency&quot; and &quot;power&quot; column.</li></ul><p><code>p</code>: int</p><ul><li>Parameter of $p$ in calculation of SBW</li></ul><p><strong>Returns</strong></p><p><code>CalcSBW</code>: float</p><ul><li>Returns the value of the SBW.</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>psd</code> does not only have columns &#39;Frequency&#39; and &#39;Power&#39;.</p><p>Raises an error if <code>p</code> is not greater than 0.</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Calculate the SBW of SignalDF, for column &#39;column1&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">psd </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.EMG2PSD(SignalDF[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;column1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SBW</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.CalcSBW(psd)</span></span></code></pre></div><hr><h2 id="extractfeatures" tabindex="-1"><code>ExtractFeatures</code> <a class="header-anchor" href="#extractfeatures" aria-label="Permalink to &quot;`ExtractFeatures`&quot;">​</a></h2><p><strong>Description</strong></p><p>Extracts usable features from two sets of <code>Signal</code> files (before and after being smoothed). Writes output to a new folder directory, as specified in <code>out_path</code>. Output is both saved to disk as a plaintext file, &quot;Features.csv&quot;, and returned as a dataframe object.</p><p>Components of a &quot;<code>Signal</code> file&quot;:</p><ul><li>Has a column named <code>Time</code> containing time indexes</li><li><code>Time</code> indexes are all equally spaced apart</li><li>Has one (or more) columns with any other name, holding the value of the electrical signal read at that time</li></ul><p>All files contained within the folder and subfolder with the proper extension are assumed to be <code>Signal</code> files. All <code>Signal</code> files within the folder and subfolders should have the same change in time between entries.</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ExtractFeatures(in_bandpass, in_smooth, out_path, sampling_rate, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">cols</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">None</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">expression</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">None</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">file_ext</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;csv&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">short_name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">True</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><strong>Theory</strong></p><p>This function requires a path to smoothed and unsmoothed data. This is because while time-series features are extracted from smoothed data, spectral features are not. High-frequency components of the signal can be lost in the smoothing, and we want to ensure the spectral features are as accurate as possible.</p><p><strong>Parameters</strong></p><p><code>in_bandpass</code>: str</p><ul><li>String filepath to a directory containing <code>Signal</code> files. The files contained within should not have a smoothing filter applied.</li></ul><p><code>in_smooth</code>: str</p><ul><li>String filepath to a directory containing <code>Signal</code> files. The files contained within should have a smoothing filter applied.</li></ul><p><code>out_path</code>: str</p><ul><li>String filepath to a directory for output feature file.</li></ul><p><code>sampling_rate</code>: int/float</p><ul><li>Numerical value of the sampling rate of the <code>Signal</code>. This is the number of entries recorded per second, or the inverse of the difference in time between entries.</li></ul><p><code>cols</code>: str (None)</p><ul><li>List of string column names. If provided, will only apply filters to specified columns. If left <code>None</code>, will apply filters to each column except for the <code>&#39;Time&#39;</code> column.</li></ul><p><code>expression</code>: str (None)</p><ul><li>String regular expression. If provided, will only apply filters to <code>Signal</code> files whose names match the regular expression, and will ignore everything else.</li></ul><p><code>exp_copy</code>: bool (False)</p><ul><li>If <code>True</code>, will copy <code>Signals</code> that don&#39;t match <code>expression</code> without modifying them to <code>out_path</code>. If <code>False</code>, <code>Signal</code> files that don&#39;t match <code>expression</code> will not appear in <code>out_path</code>.</li></ul><p><code>file_ext</code>: str (&quot;csv&quot;)</p><ul><li>String extension of the files to read. Any file in <code>in_path</code> with this extension will be considered to be a <code>Signal</code> file, and treated as such. The default is <code>&#39;csv&#39;</code>.</li></ul><p><code>short_names</code>: bool (True)</p><ul><li>Controls the naming convention of the extracted feature. If left True, will identify each file by their file name. If set to false, will identify each file by their file path. Should be left True unless some files have repeating names.</li></ul><p><strong>Returns</strong></p><p><code>ExtractFeatures</code>: pd.DataFrame</p><ul><li>Returns a Pandas dataframe, which is also written to <code>out_path</code>. Each row is a different file analyzed, marked by the file ID. Additional columns show the values of the features extracted by the function.</li></ul><p><strong>Error</strong></p><p>Raises an error if <code>in_bandpass</code> and <code>in_smooth</code> don&#39;t contain the same files.</p><p>Raises an error if the files from <code>in_bandpass</code> and <code>in_smooth</code> don&#39;t contain <code>col</code>.</p><p>Raises an error if <code>sampling_rate</code> is less or equal to 0.</p><p>Raises a warning if <code>expression</code> causes all files to be filtered out.</p><p>Raises an error if a file cannot be read in <code>in_bandpass</code> or <code>in_smooth</code>.</p><p>Raises an error if an unsupported file format was provided for <code>file_ext</code>.</p><p><strong>Example</strong></p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bandpass_path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/data/bandpass&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">smooth_path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/data/smooth&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">feature_path </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;/data/features&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sampling_rate </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2000</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cols </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;EMG_zyg&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;EMG_cor&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Extracts all features from the files in bandpass_path and</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># smooth_path. Assumes the same files are in both paths.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">features </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> EMGFlow.ExtractFeatures(bandpass_path, smooth_path, feature_path, sampling_rate, cols)</span></span></code></pre></div><hr><h2 id="sources" tabindex="-1">Sources <a class="header-anchor" href="#sources" aria-label="Permalink to &quot;Sources&quot;">​</a></h2><p>Chowdhury, R. H., Reaz, M. B. I., Ali, M. A. B. M., Bakar, A. A. A., Chellappan, K., &amp; Chang, Tae. G. (2013). Surface Electromyography Signal Processing and Classification Techniques. <em>Sensors (Basel, Switzerland)</em>, <em>13</em>(9), 12431–12466. <a href="https://doi.org/10.3390/s130912431" target="_blank" rel="noreferrer">https://doi.org/10.3390/s130912431</a></p><p>Eyben, F., Scherer, K. R., Schuller, B. W., Sundberg, J., André, E., Busso, C., Devillers, L. Y., Epps, J., Laukka, P., Narayanan, S. S., &amp; Truong, K. P. (2016). The Geneva Minimalistic Acoustic Parameter Set (GeMAPS) for Voice Research and Affective Computing. <em>IEEE Transactions on Affective Computing</em>, <em>7</em>(2), 190–202. <a href="https://doi.org/10.1109/TAFFC.2015.2457417" target="_blank" rel="noreferrer">https://doi.org/10.1109/TAFFC.2015.2457417</a></p><p>Giannakopoulos, T., &amp; Pikrakis, A. (2014). Introduction to Audio Analysis. In T. Giannakopoulos &amp; A. Pikrakis (Eds.), <em>Introduction to Audio Analysis</em> (pp. 59–103). Academic Press. <a href="https://doi.org/10.1016/B978-0-08-099388-1.00004-2" target="_blank" rel="noreferrer">https://doi.org/10.1016/B978-0-08-099388-1.00004-2</a></p><p>Hegedus, A., Trzaskoma, L., Soldos, P., Tuza, K., Katona, P., Greger, Z., Zsarnoczky-Dulhazi, F., &amp; Kopper, B. (2020). Adaptation of Fatigue Affected Changes in Muscle EMG Frequency Characteristics for the Determination of Training Load in Physical Therapy for Cancer Patients. <em>Pathology Oncology Research</em>, <em>26</em>(2), 1129–1135. <a href="https://doi.org/10.1007/s12253-019-00668-3" target="_blank" rel="noreferrer">https://doi.org/10.1007/s12253-019-00668-3</a></p><p>Llanos, F., Alexander, J. M., Stilp, C. E., &amp; Kluender, K. R. (2017). Power spectral entropy as an information-theoretic correlate of manner of articulation in American English. <em>The Journal of the Acoustical Society of America</em>, <em>141</em>(2), EL127–EL133. <a href="https://doi.org/10.1121/1.4976109" target="_blank" rel="noreferrer">https://doi.org/10.1121/1.4976109</a></p><p>McComas, A. J. (1998). Oro-facial muscles: Internal structure, function and ageing. <em>Gerodontology</em>, <em>15</em>(1), 3–14. <a href="https://doi.org/10.1111/j.1741-2358.1998.00003.x" target="_blank" rel="noreferrer">https://doi.org/10.1111/j.1741-2358.1998.00003.x</a></p><p>Nagineni, S., Taran, S., &amp; Bajaj, V. (2018). Features based on variational mode decomposition for identification of neuromuscular disorder using EMG signals. <em>Health Information Science and Systems</em>, <em>6</em>(1), 13. <a href="https://doi.org/10.1007/s13755-018-0050-4" target="_blank" rel="noreferrer">https://doi.org/10.1007/s13755-018-0050-4</a></p><p>Phinyomark, A., Limsakul, C., &amp; Phukpattaranont, P. (2009). A Novel Feature Extraction for Robust EMG Pattern Recognition. 1(1).</p><p>Roldán Jiménez, C., Bennett, P., Ortiz García, A., &amp; Cuesta Vargas, A. I. (2019). Fatigue Detection during Sit-To-Stand Test Based on Surface Electromyography and Acceleration: A Case Study. <em>Sensors (Basel, Switzerland)</em>, <em>19</em>(19), 4202. <a href="https://doi.org/10.3390/s19194202" target="_blank" rel="noreferrer">https://doi.org/10.3390/s19194202</a></p><p>Spiewak, C., Islam, M. R., Assad-Uz-Zaman, M., &amp; Rahman, M. (2018). A Comprehensive Study on EMG Feature Extraction and Classifiers. <em>Open Access Journal of Biomedical Engineering and Its Applications</em>, <em>1</em>. <a href="https://doi.org/10.32474/OAJBEB.2018.01.000104" target="_blank" rel="noreferrer">https://doi.org/10.32474/OAJBEB.2018.01.000104</a></p><p>Tjoa, S. (2022). <em>Spectral Features</em>. Music Information Retrieval. <a href="https://musicinformationretrieval.com/spectral_features.html" target="_blank" rel="noreferrer">https://musicinformationretrieval.com/spectral_features.html</a></p><p>Tkach, D., Huang, H., &amp; Kuiken, T. A. (2010). Study of stability of time-domain features for electromyographic pattern recognition. <em>Journal of NeuroEngineering and Rehabilitation</em>, <em>7</em>, 21. <a href="https://doi.org/10.1186/1743-0003-7-21" target="_blank" rel="noreferrer">https://doi.org/10.1186/1743-0003-7-21</a></p><p>Too, J., Abdullah, A. R., Mohd Saad, N., &amp; Tee, W. (2019). EMG Feature Selection and Classification Using a Pbest-Guide Binary Particle Swarm Optimization. <em>Computation</em>, <em>7</em>(1), Article 1. <a href="https://doi.org/10.3390/computation7010012" target="_blank" rel="noreferrer">https://doi.org/10.3390/computation7010012</a></p></div></div></main><footer class="VPDocFooter" data-v-5e576dee data-v-7ae10264><!--[--><!--]--><div class="edit-info" data-v-7ae10264><!----><div class="last-updated" data-v-7ae10264><p class="VPLastUpdated" data-v-7ae10264 data-v-08bf24d6>Last updated: <time datetime="2025-04-01T00:23:49.000Z" data-v-08bf24d6></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-7ae10264><span class="visually-hidden" id="doc-footer-aria-label" data-v-7ae10264>Pager</span><div class="pager" data-v-7ae10264><a class="VPLink link pager-link prev" href="/EMGFlow-Python-Package/reference/preprocess-signals.html" data-v-7ae10264><!--[--><span class="desc" data-v-7ae10264>Previous page</span><span class="title" data-v-7ae10264>Pre-processing</span><!--]--></a></div><div class="pager" data-v-7ae10264><a class="VPLink link pager-link next" href="/EMGFlow-Python-Package/reference/plot-signals.html" data-v-7ae10264><!--[--><span class="desc" data-v-7ae10264>Next page</span><span class="title" data-v-7ae10264>Plotting signals</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-d8d3e66f data-v-bc8227f9><div class="container" data-v-bc8227f9><p class="message" data-v-bc8227f9>Site built with <a href="https://vitepress.dev/">VitePress</a></p><p class="copyright" data-v-bc8227f9>Created by <a href="https://wconley.ca/">William Conley</a> and <a href="https://affectivedatascience.com">Steven R. Livingstone</a></p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"about_authors.md\":\"BAHhGGAJ\",\"about_citation.md\":\"D0DOdGBp\",\"about_contact.md\":\"ChJtyNnD\",\"guide_about-emg.md\":\"BtKDnriN\",\"guide_examples.md\":\"B8po95Kb\",\"guide_getting-started.md\":\"B2KllV9f\",\"guide_what-is-emgflow.md\":\"B1APiAPv\",\"index.md\":\"CHqxGJS3\",\"reference_api-overview.md\":\"Kfk_cViH\",\"reference_feature-extraction.md\":\"DRCeW4iC\",\"reference_file-access.md\":\"CsKe6Dl0\",\"reference_outlier-detection.md\":\"C2v4LArF\",\"reference_plot-signals.md\":\"BXm8T8IJ\",\"reference_preprocess-signals.md\":\"C3MSbMrD\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"EMGFlow\",\"titleTemplate\":\"EMG Workflow\",\"description\":\"The open workflow for EMG signal processing and feature extraction\",\"base\":\"/EMGFlow-Python-Package/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"Guide\",\"link\":\"/guide/what-is-emgflow\"},{\"text\":\"Reference\",\"link\":\"/reference/api-overview\"},{\"text\":\"About Us\",\"link\":\"/about/authors\"}],\"sidebar\":[{\"text\":\"Introduction\",\"items\":[{\"text\":\"What is EMGFlow?\",\"link\":\"/guide/what-is-emgflow\"},{\"text\":\"Getting started\",\"link\":\"/guide/getting-started\"},{\"text\":\"Examples\",\"link\":\"/guide/examples\"},{\"text\":\"About electromyography\",\"link\":\"/guide/about-emg\"}]},{\"text\":\"Reference\",\"items\":[{\"text\":\"Overview\",\"link\":\"/reference/api-overview\"},{\"text\":\"Pre-processing\",\"link\":\"/reference/preprocess-signals\"},{\"text\":\"Feature extraction\",\"link\":\"/reference/feature-extraction\"},{\"text\":\"Plotting signals\",\"link\":\"/reference/plot-signals\"},{\"text\":\"Outlier detection\",\"link\":\"/reference/outlier-detection\"},{\"text\":\"File access\",\"link\":\"/reference/file-access\"}]},{\"text\":\"About Us\",\"items\":[{\"text\":\"Authors\",\"link\":\"/about/authors\"},{\"text\":\"Citation\",\"link\":\"/about/citation\"},{\"text\":\"Contact us\",\"link\":\"/about/contact\"}]}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/WiIIson/EMGFlow-Python-Package\"}],\"footer\":{\"message\":\"Site built with <a href=\\\"https://vitepress.dev/\\\">VitePress</a>\",\"copyright\":\"Created by <a href=\\\"https://wconley.ca/\\\">William Conley</a> and <a href=\\\"https://affectivedatascience.com\\\">Steven R. Livingstone</a>\"},\"search\":{\"provider\":\"local\"},\"logo\":\"./EMGFlow.png\"},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>